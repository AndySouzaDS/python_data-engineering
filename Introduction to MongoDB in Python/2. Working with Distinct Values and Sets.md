## Categorical data validation
> What expression asserts that the distinct Nobel Prize categories catalogued by the "prizes" collection are the same as those catalogued by the
  "laureates"? Remember to explore example documents in the console via e.g. db.prizes.find_one() and db.laureates.find_one().

Possible Answers
- [ ] assert db.prizes.distinct("category") == db.laureates.distinct("prizes.category")
- [ ] assert db.prizes.distinct("laureates.category") == db.laureates.distinct("prizes.category")
- [x] assert set(db.prizes.distinct("category")) == set(db.laureates.distinct("prizes.category"))

## Never from there, but sometimes there at last
> There are some recorded countries of death ("diedCountry") that do not appear as a country of birth ("bornCountry") for laureates. One such country is "East Germany".

Instructions
- [x] Return a set of all such countries as countries.
```py
# Countries recorded as countries of death but not as countries of birth
countries = set(db.laureates.distinct("diedCountry")) - set(db.laureates.distinct("bornCountry"))
print(countries)
```

## Countries of affiliation
- [x] Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count.
```py
# The number of distinct countries of laureate affiliation for prizes
count = len(db.laureates.distinct("prizes.affiliations.country"))
print(count)
```
    29

## Born here, went there
> In which countries have USA-born laureates had affiliations for their prizes?

Possible Answers
- [x] Australia, Denmark, United Kingdom, USA
- [ ] Australia, France, Sweden, United Kingdom, USA
- [ ] Australia, Canada, Israel, United Kingdom, USA 
```py
db.laureates.distinct('prizes.affiliations.country', {'bornCountry': 'USA'})
```

## Triple plays (mostly) all around
- [x] Save a filter document criteria that, when passed to db.prizes.distinct, returns all prize categories shared by three or more laureates. That is, "laureates.2" must exist for such documents.
- [x] SSave these prize categories as a Python set called triple_play_categories.
- [x] SConfirm via an assertion that "literature" is the only prize category with no prizes shared by three or more laureates.
```py
# Save a filter for prize documents with three or more laureates
criteria = {"laureates.2": {"$exists": True}}

# Save the set of distinct prize categories in documents satisfying the criteria
triple_play_categories = set(db.prizes.distinct('category', criteria))

# Confirm literature as the only category not satisfying the criteria.
assert set(db.prizes.distinct("category")) - triple_play_categories == {"literature"}
```

## Sharing in physics after World War II
`"$elemMatch"`
> What is the approximate ratio of the number of laureates who won an unshared ({"share": "1"}) prize in physics after World War II ({"year": {"$gte": "1945"}}) to the number of laureates who won a shared prize in physics after World War II?

reference

    db.laureates.count_documents({
    "prizes": {"$elemMatch": {
        "category": "physics",
        "share": {"$ne": "1"},
        "year": {"$lt": "1945"}}}})

Possible Answers
- [ ] 0.06
- [x] 0.13
- [ ] 0.33
- [ ] 0.50
```
In [1]: db.laureates.count_documents({
            "prizes": {"$elemMatch": {
                "category": "physics",
                "share": {"$ne": "1"},
                "year": {"$gte": "1945"}}}})
Out[1]: 143
In [2]: db.laureates.count_documents({
            "prizes": {"$elemMatch": {
                "category": "physics",
                "share": "1",
                "year": {"$gte": "1945"}}}})
Out[2]: 18
In [3]: 18/143
Out[3]: 0.1258741258741259
```

## Meanwhile, in other categories...
- [x] Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than ("not in") ["physics", "chemistry", "medicine"] in or after 1945.
- [x] Save an $elemMatch filter shared to count laureates with shared (i.e., "share" is not "1") prizes in categories other than ["physics", "chemistry", "medicine"] in or after 1945.
```py
# Save a filter for laureates with unshared prizes
unshared = {
    "prizes": {"$elemMatch": {
        "category": {"$nin": ["physics", "chemistry", "medicine"]},
        "share": "1",
        "year": {"$gte": "1945"},
    }}}

# Save a filter for laureates with shared prizes
shared = {
    "prizes": {"$elemMatch": {
        "category": {"$nin": ["physics", "chemistry", "medicine"]},
        "share": {"$ne": "1"},
        "year": {"$gte": "1945"},
    }}}

ratio = db.laureates.count_documents(unshared) / db.laureates.count_documents(shared)
print(ratio)
```
    1.3653846153846154

## Organizations and prizes over time
> How many organizations won prizes before 1945 versus in or after 1945?

- [x] You won't need the $elemMatch operator at all for this exercise.
- [x] Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the "gender" field, and that dot notation is needed to access a laureate's "year" field within its "prizes" array.
- [x] Save a filter in_or_after to count organization laureates with prizes won in or after 1945.
```py
# Save a filter for organization laureates with prizes won before 1945
before = {
    "gender": "org",
    "prizes.year": {'$lt': "1945"},
    }

# Save a filter for organization laureates with prizes won in or after 1945
in_or_after = {
    "gender": "org",
    "prizes.year": {"$gte": "1945"},
    }

n_before = db.laureates.count_documents(before)
n_in_or_after = db.laureates.count_documents(in_or_after)
ratio = n_in_or_after / (n_in_or_after + n_before)
print(ratio)
```
    0.84
